package v2

// Package v2 contains the template bodies for tag methods
// using the AWS SDK Go V2.

const HeaderBody = `
// Code generated by internal/generate/tags/main.go; DO NOT EDIT.
package {{ .ServicePackage }}

import (
	{{- if .FmtPkg }}
	"fmt"
	{{- end }}
	"context"
	{{- if .StrConvPkg }}
	"strconv"
	{{- end }}

	"github.com/aws/aws-sdk-go-v2/aws"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	{{- if .AWSService }}
	"github.com/aws/aws-sdk-go-v2/service/{{ .AWSService }}"
	"github.com/aws/aws-sdk-go-v2/service/{{ .AWSService }}/types"
	{{- end }}
	{{- if .HelperSchemaPkg }}
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	{{- end }}
	{{- if .ParentNotFoundErrCode }}
	"github.com/hashicorp/aws-sdk-go-base/v2/awsv1shim/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	{{- end }}
	{{- if .TfResourcePkg }}
    "github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	{{- end }}
)

`

const GetTagBody = `
// GetTag fetches an individual {{ .ServicePackage }} service tag for a resource.
// Returns whether the key value and any errors. A NotFoundError is used to signal that no value was found.
// This function will optimise the handling over ListTags, if possible.
// The identifier is typically the Amazon Resource Name (ARN), although
// it may also be a different identifier depending on the service.
{{- if or ( .TagTypeIDElem ) ( .TagTypeAddBoolElem ) }}
func GetTag(ctx context.Context, conn {{ .ClientType }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}, key string) (*tftags.TagData, error) {
{{- else }}
func GetTag(ctx context.Context, conn {{ .ClientType }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}, key string) (*string, error) {
{{- end }}
	{{- if .ListTagsInFiltIDName }}
	input := &{{ .AWSService  }}.{{ .ListTagsOp }}Input{
		Filters: []*{{ .AWSService  }}.Filter{
			{
				Name:   aws.String("{{ .ListTagsInFiltIDName }}"),
				Values: []*string{aws.String(identifier)},
			},
			{
				Name:   aws.String("key"),
				Values: []*string{aws.String(key)},
			},
		},
	}

	output, err := conn.{{ .ListTagsOp }}(ctx, input)

	if err != nil {
		return nil, err
	}

	listTags := KeyValueTags(output.{{ .ListTagsOutTagsElem }}{{ if .TagTypeIDElem }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }}{{ end }})
	{{- else }}
	listTags, err := ListTags(ctx, conn, identifier{{ if .TagResTypeElem }}, resourceType{{ end }})

	if err != nil {
		return nil, err
	}
	{{- end }}

	if !listTags.KeyExists(key) {
		return nil, tfresource.NewEmptyResultError(nil)
	}

	{{ if or ( .TagTypeIDElem ) ( .TagTypeAddBoolElem) }}
	return listTags.KeyTagData(key), nil
	{{- else }}
	return listTags.KeyValue(key), nil
	{{- end }}
}
`

const ListTagsBody = `
// ListTags lists {{ .ServicePackage }} service tags.
// The identifier is typically the Amazon Resource Name (ARN), although
// it may also be a different identifier depending on the service.
func ListTags(ctx context.Context, conn {{ .ClientType }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}) (tftags.KeyValueTags, error) {
	input := &{{ .TagPackage  }}.{{ .ListTagsOp }}Input{
		{{- if .ListTagsInFiltIDName }}
		Filters: []*{{ .AWSService  }}.Filter{
			{
				Name:   aws.String("{{ .ListTagsInFiltIDName }}"),
				Values: []*string{aws.String(identifier)},
			},
		},
		{{- else }}
		{{- if .ListTagsInIDNeedSlice }}
		{{ .ListTagsInIDElem }}: aws.StringSlice([]string{identifier}),
		{{- else }}
		{{ .ListTagsInIDElem }}: aws.String(identifier),
		{{- end }}
		{{- if .TagResTypeElem }}
		{{ .TagResTypeElem }}:         aws.String(resourceType),
		{{- end }}
		{{- end }}
	}

	output, err := conn.{{ .ListTagsOp }}(ctx, input)

	{{ if and ( .ParentNotFoundErrCode ) ( .ParentNotFoundErrMsg ) }}
			var *types.ResourceNotFoundException
			if tfawserr.ErrMessageContains(err, "{{ .ParentNotFoundErrCode }}", "{{ .ParentNotFoundErrMsg }}") {
				return nil, &resource.NotFoundError{
					LastError:   err,
					LastRequest: input,
				}
			}
	{{- else if ( .ParentNotFoundErrCode ) }}
			if tfawserr.ErrCodeEquals(err, "{{ .ParentNotFoundErrCode }}") {
				return nil, &resource.NotFoundError{
					LastError:   err,
					LastRequest: input,
				}
			}
	{{- end }}

	if err != nil {
		return tftags.New(nil), err
	}

	return KeyValueTags(output.{{ .ListTagsOutTagsElem }}{{ if .TagTypeIDElem }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }}{{ end }}), nil
}
`

const ServiceTagsMapBody = `
// map[string]*string handling

// Tags returns {{ .ServicePackage }} service tags.
func Tags(tags tftags.KeyValueTags) map[string]*string {
	return aws.StringMap(tags.Map())
}

// KeyValueTags creates KeyValueTags from {{ .ServicePackage }} service tags.
func KeyValueTags(tags map[string]*string) tftags.KeyValueTags {
	return tftags.New(tags)
}
`

const ServiceTagsSliceBody = `
// []*SERVICE.Tag handling

{{ if and ( .TagTypeIDElem ) ( .TagTypeAddBoolElem ) }}
// ListOfMap returns a list of {{ .ServicePackage }} in flattened map.
//
// Compatible with setting Terraform state for strongly typed configuration blocks.
//
// This function strips tag resource identifier and type. Generally, this is
// the desired behavior so the tag schema does not require those attributes.
// Use (tftags.KeyValueTags).ListOfMap() for full tag information.
func ListOfMap(tags tftags.KeyValueTags) []interface{} {
	var result []interface{}

	for _, key := range tags.Keys() {
		m := map[string]interface{}{
			"key":                   key,
			"value":                 aws.ToString(tags.KeyValue(key)),
			{{ if .TagTypeAddBoolElem }}
			"{{ .TagTypeAddBoolElemSnake }}": aws.ToBool(tags.KeyAdditionalBoolValue(key, "{{ .TagTypeAddBoolElem }}")),
			{{ end }}
		}

		result = append(result, m)
	}

	return result
}
{{- end }}

{{ if eq .ServicePackage "autoscaling" }}
// ListOfStringMap returns a list of {{ .ServicePackage }} tags in flattened map of only string values.
//
// Compatible with setting Terraform state for legacy []map[string]string schema.
// Deprecated: Will be removed in a future major version without replacement.
func ListOfStringMap(tags tftags.KeyValueTags) []interface{} {
	var result []interface{}

	for _, key := range tags.Keys() {
		m := map[string]string{
			"key":                   key,
			"value":                 aws.ToString(tags.KeyValue(key)),
			{{ if .TagTypeAddBoolElem }}
			"{{ .TagTypeAddBoolElemSnake }}": strconv.FormatBool(aws.ToBool(tags.KeyAdditionalBoolValue(key, "{{ .TagTypeAddBoolElem }}"))),
			{{ end }}
		}

		result = append(result, m)
	}

	return result
}
{{- end }}

{{- if .TagKeyType }}
// TagKeys returns {{ .ServicePackage }} service tag keys.
func TagKeys(tags tftags.KeyValueTags) []*{{ .AWSService }}.{{ .TagKeyType }} {
	result := make([]*{{ .AWSService }}.{{ .TagKeyType }}, 0, len(tags))

	for k := range tags.Map() {
		tagKey := &{{ .AWSService }}.{{ .TagKeyType }}{
			{{ .TagTypeKeyElem }}: aws.String(k),
		}

		result = append(result, tagKey)
	}

	return result
}
{{- end }}

// Tags returns {{ .ServicePackage }} service tags.
func Tags(tags tftags.KeyValueTags) []types.{{ .TagType }} {
	{{- if or ( .TagTypeIDElem ) ( .TagTypeAddBoolElem) }}
	var result []types.{{ .TagType }}

	for _, key := range tags.Keys() {
		tag := types.{{ .TagType }}{
			{{ .TagTypeKeyElem }}:        aws.String(key),
			{{ .TagTypeValElem }}:      tags.KeyValue(key),
			{{- if ( .TagTypeIDElem ) }}
			{{ .TagTypeIDElem }}: tags.KeyAdditionalStringValue(key, "{{ .TagTypeIDElem }}"),
			{{- if ( .TagResTypeElem ) }}
			{{ .TagResTypeElem }}:   tags.KeyAdditionalStringValue(key, "{{ .TagResTypeElem }}"),
			{{- end }}
			{{- end }}
			{{- if .TagTypeAddBoolElem }}
			{{ .TagTypeAddBoolElem }}:                          tags.KeyAdditionalBoolValue(key, "{{ .TagTypeAddBoolElem }}"),
			{{- end }}
		}

		result = append(result, tag)
	}
	{{- else }}
	result := make([]types.{{ .TagType }}, 0, len(tags))

	for k, v := range tags.Map() {
		tag := types.{{ .TagType }}{
			{{ .TagTypeKeyElem }}:   aws.String(k),
			{{ .TagTypeValElem }}: aws.String(v),
		}

		result = append(result, tag)
	}
	{{- end }}

	return result
}

// KeyValueTags creates tftags.KeyValueTags from {{ .AWSService }} service tags.
{{- if or ( .TagType2 ) ( .TagTypeAddBoolElem ) }}
//
// Accepts the following types:
//   - []types.{{ .TagType }}
{{- if .TagType2 }}
//   - []types.{{ .TagType2 }}
{{- end }}
{{- if .TagTypeAddBoolElem }}
//   - []interface{} (Terraform TypeList configuration block compatible)
//   - *schema.Set (Terraform TypeSet configuration block compatible)
{{- end }}
func KeyValueTags(tags interface{}{{ if .TagTypeIDElem }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}{{ end }}) tftags.KeyValueTags {
	switch tags := tags.(type) {
	case []types.{{ .TagType }}:
		{{- if or ( .TagTypeIDElem ) ( .TagTypeAddBoolElem) }}
		m := make(map[string]*tftags.TagData, len(tags))

		for _, tag := range tags {
			tagData := &tftags.TagData{
				Value: tag.{{ .TagTypeValElem }},
			}

			tagData.AdditionalBoolFields = make(map[string]*bool)
			{{- if .TagTypeAddBoolElem }}
			tagData.AdditionalBoolFields["{{ .TagTypeAddBoolElem }}"] = tag.{{ .TagTypeAddBoolElem }}
			{{- end }}

			{{- if .TagTypeIDElem }}
			tagData.AdditionalStringFields = make(map[string]*string)
			tagData.AdditionalStringFields["{{ .TagTypeIDElem }}"] = &identifier
			{{- if .TagResTypeElem }}
			tagData.AdditionalStringFields["{{ .TagResTypeElem }}"] = &resourceType
			{{- end }}
			{{- end }}

			m[aws.ToString(tag.{{ .TagTypeKeyElem }})] = tagData
		}
		{{- else }}
		m := make(map[string]*string, len(tags))

		for _, tag := range tags {
			m[aws.ToString(tag.{{ .TagTypeKeyElem }})] = tag.{{ .TagTypeValElem }}
		}
		{{- end }}

		return tftags.New(m)
	case []*{{ .AWSService }}.{{ .TagType2 }}:
		{{- if or ( .TagTypeIDElem ) ( .TagTypeAddBoolElem) }}
		m := make(map[string]*tftags.TagData, len(tags))

		for _, tag := range tags {
			tagData := &tftags.TagData{
				Value: tag.{{ .TagTypeValElem }},
			}

			{{- if .TagTypeAddBoolElem }}
			tagData.AdditionalBoolFields = make(map[string]*bool)
			tagData.AdditionalBoolFields["{{ .TagTypeAddBoolElem }}"] = tag.{{ .TagTypeAddBoolElem }}
			{{- end }}

			{{- if .TagTypeIDElem }}
			tagData.AdditionalStringFields = make(map[string]*string)
			tagData.AdditionalStringFields["{{ .TagTypeIDElem }}"] = &identifier
			{{- if .TagResTypeElem }}
			tagData.AdditionalStringFields["{{ .TagResTypeElem }}"] = &resourceType
			{{- end }}
			{{- end }}

			m[aws.ToString(tag.{{ .TagTypeKeyElem }})] = tagData
		}
		{{- else }}
		m := make(map[string]*string, len(tags))

		for _, tag := range tags {
			m[aws.ToString(tag.{{ .TagTypeKeyElem }})] = tag.{{ .TagTypeValElem }}
		}
		{{- end }}

		return tftags.New(m)
	{{- if .TagTypeAddBoolElem }}
	case *schema.Set:
		return KeyValueTags(tags.List(){{ if .TagTypeIDElem }}, identifier{{ if .TagResTypeElem }}, resourceType{{ end }}{{ end }})
	case []interface{}:
		result := make(map[string]*tftags.TagData)

		for _, tfMapRaw := range tags {
			tfMap, ok := tfMapRaw.(map[string]interface{})

			if !ok {
				continue
			}

			key, ok := tfMap["key"].(string)

			if !ok {
				continue
			}

			tagData := &tftags.TagData{}

			if v, ok := tfMap["value"].(string); ok {
				tagData.Value = &v
			}

			{{ if .TagTypeAddBoolElem }}
			tagData.AdditionalBoolFields = make(map[string]*bool)
			{{- if .TagTypeAddBoolElem }}
			if v, ok := tfMap["{{ .TagTypeAddBoolElemSnake }}"].(bool); ok {
				tagData.AdditionalBoolFields["{{ .TagTypeAddBoolElem }}"] = &v
			}
			{{- end }}
			{{ if eq .ServicePackage "autoscaling" }}
			// Deprecated: Legacy map handling
			{{- if .TagTypeAddBoolElem }}
			if v, ok := tfMap["{{ .TagTypeAddBoolElemSnake }}"].(string); ok {
				b, _ := strconv.ParseBool(v)
				tagData.AdditionalBoolFields["{{ .TagTypeAddBoolElem }}"] = &b
			}
			{{- end }}
			{{- end }}
			{{- end }}

			{{ if .TagTypeIDElem }}
			tagData.AdditionalStringFields = make(map[string]*string)
			tagData.AdditionalStringFields["{{ .TagTypeIDElem }}"] = &identifier
			{{- if .TagResTypeElem }}
			tagData.AdditionalStringFields["{{ .TagResTypeElem }}"] = &resourceType
			{{- end }}
			{{- end }}

			result[key] = tagData
		}

		return tftags.New(result)
	{{- end }}
	default:
		return tftags.New(nil)
	}
}
{{- else }}
func KeyValueTags(tags []types.{{ .TagType }}) tftags.KeyValueTags {
	m := make(map[string]*string, len(tags))

	for _, tag := range tags {
		m[aws.ToString(tag.{{ .TagTypeKeyElem }})] = tag.{{ .TagTypeValElem }}
	}

	return tftags.New(m)
}
{{- end }}
`

const UpdateTagsBody = `
// UpdateTags updates {{ .ServicePackage }} service tags.
// The identifier is typically the Amazon Resource Name (ARN), although
// it may also be a different identifier depending on the service.
{{- if  .TagTypeAddBoolElem }}
func UpdateTags(ctx context.Context, conn {{ .ClientType }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}, oldTagsSet interface{}, newTagsSet interface{}) error {
	oldTags := KeyValueTags(oldTagsSet, identifier{{ if .TagResTypeElem }}, resourceType{{ end }})
	newTags := KeyValueTags(newTagsSet, identifier{{ if .TagResTypeElem }}, resourceType{{ end }})
{{- else }}
func UpdateTags(ctx context.Context, conn {{ .ClientType }}, identifier string{{ if .TagResTypeElem }}, resourceType string{{ end }}, oldTagsMap interface{}, newTagsMap interface{}) error {
	oldTags := tftags.New(oldTagsMap)
	newTags := tftags.New(newTagsMap)
{{- end }}
	{{- if eq (.TagOp) (.UntagOp) }}
	removedTags := oldTags.Removed(newTags)
	updatedTags := oldTags.Updated(newTags)

	// Ensure we do not send empty requests
	if len(removedTags) == 0 && len(updatedTags) == 0 {
		return nil
	}

	input := &{{ .AWSService }}.{{ .TagOp }}Input{
		{{- if not ( .TagTypeIDElem ) }}
		{{- if .TagInIDNeedSlice }}
		{{ .TagInIDElem }}:   aws.StringSlice([]string{identifier}),
		{{- else }}
		{{ .TagInIDElem }}:   aws.String(identifier),
		{{- end }}
		{{- if .TagResTypeElem }}
		{{ .TagResTypeElem }}:      aws.String(resourceType),
		{{- end }}
		{{- end }}
	}

	if len(updatedTags) > 0 {
		input.{{ .TagInTagsElem }} = Tags(updatedTags.IgnoreAWS())
	}

	if len(removedTags) > 0 {
		{{- if .UntagInNeedTagType }}
		input.{{ .UntagInTagsElem }} = Tags(removedTags.IgnoreAWS())
		{{- else if .UntagInNeedTagKeyType }}
		input.{{ .UntagInTagsElem }} = TagKeys(removedTags.IgnoreAWS())
		{{- else if .UntagInCustomVal }}
		input.{{ .UntagInTagsElem }} = {{ .UntagInCustomVal }}
		{{- else }}
		input.{{ .UntagInTagsElem }} = aws.StringSlice(removedTags.Keys())
		{{- end }}
	}

	_, err := conn.{{ .TagOp }}(ctx, input)

	if err != nil {
		return fmt.Errorf("error tagging resource (%s): %w", identifier, err)
	}

	{{- else }}

	if removedTags := oldTags.Removed(newTags); len(removedTags) > 0 {
		{{- if .TagOpBatchSize }}
		for _, removedTags := range removedTags.Chunks({{ .TagOpBatchSize }}) {
		{{- end }}
		input := &{{ .TagPackage }}.{{ .UntagOp }}Input{
			{{- if not ( .TagTypeIDElem ) }}
			{{- if .TagInIDNeedSlice }}
			{{ .TagInIDElem }}:   aws.StringSlice([]string{identifier}),
			{{- else }}
			{{ .TagInIDElem }}:   aws.String(identifier),
			{{- end }}
			{{- if .TagResTypeElem }}
			{{ .TagResTypeElem }}: aws.String(resourceType),
			{{- end }}
			{{- end }}
			{{- if .UntagInNeedTagType }}
			{{ .UntagInTagsElem }}:       Tags(removedTags.IgnoreAWS()),
			{{- else if .UntagInNeedTagKeyType }}
			{{ .UntagInTagsElem }}:       TagKeys(removedTags.IgnoreAWS()),
			{{- else if .UntagInCustomVal }}
			{{ .UntagInTagsElem }}:       {{ .UntagInCustomVal }},
			{{- else }}
			{{ .UntagInTagsElem }}:       removedTags.IgnoreAWS().Keys(),
			{{- end }}
		}

		_, err := conn.{{ .UntagOp }}(ctx, input)

		if err != nil {
			return fmt.Errorf("error untagging resource (%s): %w", identifier, err)
		}
		{{- if .TagOpBatchSize }}
		}
		{{- end }}
	}

	if updatedTags := oldTags.Updated(newTags); len(updatedTags) > 0 {
		{{- if .TagOpBatchSize }}
		for _, updatedTags := range updatedTags.Chunks({{ .TagOpBatchSize }}) {
		{{- end }}
		input := &{{ .TagPackage }}.{{ .TagOp }}Input{
			{{- if not ( .TagTypeIDElem ) }}
			{{- if .TagInIDNeedSlice }}
			{{ .TagInIDElem }}: aws.StringSlice([]string{identifier}),
			{{- else }}
			{{ .TagInIDElem }}: aws.String(identifier),
			{{- end }}
			{{- if .TagResTypeElem }}
			{{ .TagResTypeElem }}:    aws.String(resourceType),
			{{- end }}
			{{- end }}
			{{- if .TagInCustomVal }}
			{{ .TagInTagsElem }}:       {{ .TagInCustomVal }},
			{{- else }}
			{{ .TagInTagsElem }}:       Tags(updatedTags.IgnoreAWS()),
			{{- end }}
		}

		_, err := conn.{{ .TagOp }}(ctx, input)

		if err != nil {
			return fmt.Errorf("error tagging resource (%s): %w", identifier, err)
		}
		{{- if .TagOpBatchSize }}
		}
		{{- end }}
	}

	{{- end }}

	return nil
}
`
